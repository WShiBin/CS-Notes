## Overview

> CMake is a _build-system generator_ , offering a powerful domain-specific language (DSL) to describe what the build system should achieve

## Componnet

-   **CMake** lets you describe how your project, whether building an executable, libraries, or both, has to be configured, built, and installed on all major hardware and operating systemsç”¨æ¥æè¿°ä½ çš„é¡¹ç›®,ä¸ç®¡æ˜¯ç”Ÿæˆå¯æ‰§è¡Œç¨‹åºè¿˜æ˜¯åº“,æˆ–è€…ä¸¤è€…,æ˜¯å¦‚ä½•configured,built,å’Œinstallåœ¨æ‰€æœ‰ä¸»è¦çš„ç¡¬ä»¶å’Œæ“ä½œç³»ç»Ÿä¸Š
-   **CTest** allows you to define tests, test suites, and set how they should be executed.å…è®¸ä½ å»å®šä¹‰æµ‹è¯•,æµ‹è¯•å¥—ä»¶,å’Œè®¾ç½®ä»–ä»¬æ˜¯å¦‚ä½•å»æ‰§è¡Œ
-   **CPack** offers a DSL for all your packaging needs, whether your project should be bundled and distributed in source code or platform-native binary form.
-   **CDash** will be useful for reporting the results of tests for your project to an online dashboardæŠŠé¡¹ç›®testçš„è¿”å›å€¼reportåˆ°an online dashboardä¸Š: ç›‘æ§æµ‹è¯•ç»“æœ

### Topics

-   Configure, build, test, and install code projects using CMake
-   Detect operating systems, processors, libraries, files, and programs for conditional compilation
-   Increase the portability of your code
-   Refactor a large code base into modules with the help of CMake Build multi-language projects
-   Know where and how to tweak CMake configuration files written by somebody else
-   Package projects for distribution
-   Port projects to CMake

## Workflow

![image-20191105202249267](assets/image-20191105202249267.png)

-   **CMake time** or **configure time**:å½“ cmake è¿è¡Œæ—¶,cmake ä¼šå»å¤„ç†é¡¹ç›®ä¸­çš„ CMakeLists.txt,é…ç½®è¿™ä¸ªé¡¹ç›®
-   **Generation time**. åœ¨é…ç½®æˆåŠŸå,CMake ä¼šåœ¨é¡¹ç›®ä¸­ç”Ÿæˆ**æœ¬åœ°æ„å»ºå·¥å…·**éœ€è¦çš„è„šæœ¬,ç”¨æ¥æ‰§è¡Œååºçš„æ­¥éª¤
-   **Build time**. å½“æœ¬åœ°æ„å»ºå·¥å…·è¢« cmake è°ƒç”¨,æœ¬åœ°å·¥å…·æ„å»ºç”Ÿæˆçš„è„šæœ¬,This is when the native build tools are invoked on the platform- and tool-native build scripts previously generated by CMake.
-   ç¼–è¯‘å™¨ä¼šè¢«è°ƒç”¨,targets ä¼šè¢«ç”Ÿæˆåˆ°æŒ‡å®šçš„ç›®å½•
-   Note the recursive CMake-time arrow: this can seem baffling, but it is a mechanism we will use many times throughout the book to achieve a truly platform-independent build.
-   **CTest time** or **test time**. åœ¨è¿è¡Œé¡¹ç›®çš„ test è¿è¡Œå¥—ä»¶æ—¶
-   **CDash time** or **report time**. å½“é¡¹ç›®æµ‹è¯•çš„è¿”å›ä»©è¢«ä¸Šä¼ åˆ°æ§åˆ¶é¢æ¿,å»åˆ†äº«ç»™å…¶ä»–å¼€å‘è€…äºº
-   **Install time**. å½“é¡¹ç›®çš„ç”Ÿæˆçš„ targets,èµ„æºæ–‡ä»¶,å¯æ‰§è¡Œæ–‡ä»¶,åº“ä»æ„å»ºç›®å½•è¢«å®‰è£…åˆ°å®‰è£…ç›®å½•ä¸‹
-   **CPack time** or **packaging time**. æ‰“åŒ…æˆæºä»£ç æˆ–æ˜¯äºŒè¿›åˆ¶æ–‡ä»¶, åˆ†å‘é¡¹ç›®,
-   **Package install time**. å½“æ–°ç”Ÿæˆçš„åŒ…è¢«å®‰è£…åˆ°ç³»ç»Ÿå†…

### HelloWorld

CMakeLists.txt æ–‡ä»¶åå¿…éœ€ç›¸åŒ

```cmake
# set minimum cmake version
cmake_minimum_required(VERSION 3.10.0 FATAL_ERROR)
project(hello-world VERSION 0.1 LANGUAGES CXX)
add_executable(helloworld hello-world.cpp)
```

-   å‘½ä»¤å¤§å°å†™ä¸æ•æ„Ÿ
-   å‚æ•°å¤§å°å†™æ•æ„Ÿ

```shell
cmake --help
mkdir build
cmake -S. -Bbuild # é…ç½®,æŒ‡å®šsource codeçš„ç›®å½•,æŒ‡å®šbuildç”Ÿæˆçš„ç›®å½•
cmake --build build # ç”Ÿæˆtarget,æŒ‡å®šbuildç”Ÿæˆçš„ç›®å½•
cmake --build . --target help # target list

cmake -G Ninja ..
```

build ç›®å½•

-   Makefile:make çš„æ„å»ºè¯­å¥å’Œæ„å»ºè§„åˆ™(ä¸åŒç¼–è¯‘ç³»ç»Ÿä¸ä¸€æ ·)
-   CMakeFiles: CMake åœ¨é…ç½®è¿‡ç¨‹ä¸­ç”Ÿæˆçš„ä¸´æ—¶æ–‡ä»¶
-   cmake_install.cmake: CMake è„šæœ¬:ç”¨äºå¤„ç†ç¨‹åºå®‰è£…æ—¶çš„è§„åˆ™
-   CMakeCache.txt: CMake ç¼“å­˜æ–‡ä»¶

target

-   all: default é»˜è®¤ target
-   clean: æ¸…ç† build ç”Ÿæˆçš„æ–‡ä»¶
-   depend: è°ƒç”¨ cmake ç”Ÿæˆä¾èµ–
-   rebuild_cache: é‡æ–°ç”Ÿæˆç¼“å­˜æ–‡ä»¶
-   edit_cache: this target will let you edit cache entries directly.
-   test: will run the test suite with the help of CTest. We will discuss testing and CTest extensively in Chap ter 4,_CreatingandRunningTests_.
-   install: will execute the installation rules for the project. 
-   package: this target will invoke CPack to generate a redistributable package for the project.

## Command æŒ‡ä»¤

add_library

-   STATIC : create static libraries,
-   SHARED : create shared libraries, shared object
-   OBJECT : ä»æºä»£ç ç¼–è¯‘å‡º object æ–‡ä»¶,ä½†æ˜¯,è¿™ä¸ªæ–‡ä»¶æ—¢ä¸èƒ½å½’æ¡£åˆ°é™æ€åº“,ä¹Ÿä¸èƒ½é“¾æ¥åˆ°åŠ¨æ€åº“; å½“éœ€è¦ä¸€æ¬¡åˆ›å»ºåŠ¨æ€åº“å’Œé™æ€åº“æ—¶ä½¿ç”¨
-   MODULE : å¦ä¸€ç§åŠ¨æ€åº“(å…±äº«åº“),å’ŒåŠ¨æ€åº“ç›¸æ¯”,ä¸èƒ½è¢«é“¾æ¥åˆ°ä»»ä½•çš„ target, ä½†ä»–å¯èƒ½ä¼šåœ¨ä¹‹åè¢«åŠ¨æ€çš„åŠ è½½, ä½œä¸ºå‚æ•°åœ¨æ„å»ºä¸€ä¸ªè¿è¡Œæ’ä»¶æ—¶ä½¿ç”¨
-   IMPORTED,è¿™ç§ç±»å‹çš„åº“ä½äºé¡¹ç›®ä¹‹å¤–,ä¸»è¦ç”¨é€”æ˜¯å¯¹ä¸Šæ¸¸è½¯ä»¶åŒ…æä¾›çš„é¡¹ç›®çš„ç°æœ‰ä¾èµ–å…³ç³»è¿›è¡Œå»ºæ¨¡
-   INTERFACE: å’Œ IMPORTED ç±»ä¼¼,ä½†æ˜¯æ˜¯å¯å˜çš„,ä¹Ÿæ²¡æœ‰ location,Its main use case is to model usage requirements for a target that is outside our project.
-   ALIAS: ç”¨äºå®šä¹‰ä¸€ä¸ªåº“çš„åˆ«å,ä½†ä¸èƒ½ç”¨äº IMPORTED çš„åº“ target

set_target_properties

set

list(APPEND \_sources Message.hpp Message.cpp)

option(<variable> "<help_text>" [value])

## Variables å˜é‡

-   USE_LIBRARY
-   BUILD_SHARED_LIBS: å…¨å±€å˜é‡, å¦‚æœ add_library æ²¡æœ‰æŒ‡å®šç¬¬äºŒä¸ªå‚æ•°,å°±ä¼šæ¥æ‰¾è¿™ä¸ªå˜é‡,
-

## Module æ¨¡å—

> CMake has mechanisms in place to extend its syntax and capabilities through the inclusion of _modules_, either shipped with CMake itself or custom ones, CMake æœ‰ä¸€ç§èƒ½åœ¨åˆé€‚çš„åœ°æ–¹é€šè¿‡å¼•å…¥æ¨¡å—,è¦ä¹ˆä½¿ç”¨ä»–è‡ªå·±çš„, å°±æ˜¯å»è‡ªå®šä¹‰ä¸€ä¸ª,å»æ‹“å±•ä»–è‡ªå·±çš„è¯­æ³•å’Œèƒ½åŠ›

### CMakeDependentOption

```cmake
cmake --help-module-list #æŸ¥çœ‹æ‰€æœ‰çš„moduleåˆ—è¡¨


include(CMakeDependentOption)

# second option depends on the value of the first
cmake_dependent_option(
  MAKE_STATIC_LIBRARY "Compile sources into a static library" ON
  "USE_LIBRARY" OFF
  )

# third option depends on the value of the first
cmake_dependent_option(
  MAKE_SHARED_LIBRARY "Compile sources into a shared library" ON
  "USE_LIBRARY" ON
  )
```

## æŒ‡å®šç¼–è¯‘å™¨

ä¸¤ç§æ–¹å¼ä¿®æ”¹ç¼–è¯‘å™¨:

-   è®¾ç½®`CMAKE_<LANG>_COMPILER`å˜é‡:LANG(CXX, C, or Fortran)
-   å‘½ä»¤è¡Œä¼ å‚æ•°:
    -   CMake ä¼ å‚æ•°`cmake -D CMAKE_CXX_COMPILER=clang++ ..` ğŸ‘
    -   å¯¼å‡ºå˜é‡:ğŸ‘ğŸ¿
        -   æŒ‡å®š C++ç¼–è¯‘å™¨:`env CXX=clang++ cmake ..`
        -   æŒ‡å®š C ç¼–è¯‘å™¨:`env CC=clang cmake ..`

> **Explicit is better than implicit**

> At configure time, CMake performs a series of platform tests to determine which compilers are available, å–å†³äºå¹³å°å’Œç¼–è¯‘å™¨
>
> * The first test CMake performs is based on the name of the compiler for the project language



### 7.Switching build type

å˜é‡CMAKE_BUILD_TYPE

* Debug: è¿™ä¸ªç‰ˆæœ¬æ²¡æœ‰ä¼˜åŒ–targetç›®æ ‡,ä¼šå¸¦ä¸€äº›debug symbol
* Release: ç›¸å, ä¼šæ„å»ºä¼˜åŒ–targetç›®æ ‡,ä¸ä¼šå¸¦debug symbol
* RelWithDebInfo: å¸¦æœ‰å°‘é‡çš„ä¼˜åŒ–å’Œdebug symbolçš„targetç›®æ ‡
* MinSizeRel:æœ€å°åŒ–æ„å»ºtargetç›®æ ‡

```cmake
cmake -D CMAKE_BUILD_TYPE=Release ..

cmake_minimum_required(VERSION 3.10.0 FATAL_ERROR)

project(demo LANGUAGES CXX)

message(STATUS "build type : ${CMAKE_BUILD_TYPE}")
if(NOT CMAKE_BUILD_TYPE)
  set(CMAKE_BUILD_TYPE Release CACHE STRING "build type " FORCE)
endif(NOT CMAKE_BUILD_TYPE)

message(STATUS "build type : ${CMAKE_BUILD_TYPE}")

message(STATUS "C flags, Debug configuration: ${CMAKE_C_FLAGS_DEBUG}")
message(STATUS "C flags, Release configuration: ${CMAKE_C_FLAGS_RELEASE}")
message(STATUS "C flags, Release configuration with Debug info: ${CMAKE_C_FLAGS_RELWITHDEBINFO}")
message(STATUS "C flags, minimal Release configuration: ${CMAKE_C_FLAGS_MINSIZEREL}")

message(STATUS "C++ flags, Debug configuration: ${CMAKE_CXX_FLAGS_DEBUG}")
message(STATUS "C++ flags, Release configuration: ${CMAKE_CXX_FLAGS_RELEASE}")
message(STATUS "C++ flags, Release configuration with Debug info: ${CMAKE_CXX_FLAGS_RELWITHDEBINFO}")
message(STATUS "C++ flags, minimal Release configuration: ${CMAKE_CXX_FLAGS_MINSIZEREL}")
```



### 8.controlling complier flags
ä¸¤ç§æ–¹å¼
* target_compile_optionså‘½ä»¤: ä¸ºæ¯ä¸€ä¸ªtargetæŒ‡å®šflags,ä¸ä¼šé‡å†™CMakeé»˜è®¤çš„
* Cliå‚æ•°:`CMAKE_<LANG>_FLAGS_<CONFIG>`å…¨å±€çš„å˜é‡,ä¼šåœ¨æ‰€æœ‰çš„targetéƒ½ç”Ÿæ•ˆ

#### target_compile_options

* PRIVATE: compile options will only be applied to the given target and not to other targets consuming it.
* PUBLIC: compile options will be applied to the given target and all other targets consuming it.
* INTERFACE: compile options on a given target will only be applied to targets consuming it.

```shell
cmake --build . -- VERBOSE=1
```

### 9.Setting the standard for the language

```cmake
add_library(animals
  SHARED
    Animal.cpp
    Animal.hpp
    Cat.cpp
    Cat.hpp
    Dog.cpp
    Dog.hpp
    Factory.hpp
)

set_target_properties(animals PROPERTIES
	CXX_STANDARD 14 
	CXX_EXTENSIONS OFF 
	CXX_STANDARD_REQUIRED ON 
	POSITION_INDEPENDENT_CODE 1
)
```

* CXX_STANDARD è®¾ç½®ä½¿ç”¨æ ‡å‡†çš„ç‰ˆæœ¬.
* CXX_EXTENSIONS å‘Šè¯‰CMakeä»…ä»…ä½¿ç”¨ç¼–è¯‘å™¨ISO C++æ ‡å‡†çš„flags,ä¸ä½¿ç”¨ç‰¹å®šç¼–è¯‘å™¨çš„æ‹“å±•çš„flags
* CXX_STANDARD_REQUIRED æŒ‡å®šéœ€è¦çš„æ ‡å‡†ç‰ˆæœ¬ å¦‚æœè¿™ä¸ªç‰ˆæœ¬ä¸å¯ç”¨, CMakeä¼šåœæ­¢é…ç½®,å¹¶æŠ¥é”™, å½“è®¾ç½®æˆOFF,CMakeä¼šå»æ‰¾ä¸‹ä¸€ä¸ªæœ€åçš„æ ‡å‡†ç‰ˆæœ¬,èµ°åˆ°æ­£ç¡®çš„flagsè¢«è®¾ç½®, This means to first look for C++14, then C++11, then C++98. 

target_compile_features

> CMake offers an even finer level of control over the language standard by introducing the concept of *compile features*. These are features introduced by the language standard, such as variadic templates and lambdas in C++11, and automatic return type deduction in C++14. You can ask for certain features to be available for specific targets with the target_compile_features() command and CMake will automatically set the correct compiler flag for the standard. It is also possible to have CMake generate compatibility headers for optional compiler features. 



set_source_files_properties 
```cmake
set_source_files_properties([file1 [file2 [...]]]
                            PROPERTIES prop1 value1
                            [prop2 value2 [...]])
```
ç»™source fileè®¾ç½®propertieså‚æ•°
https://cmake.org/cmake/help/v3.5/manual/cmake-properties.7.html#properties-on-source-files


get_source_file_property 
```cmake
get_source_file_property(VAR file property)
```
æŠŠfileçš„propertyå±æ€§å€¼å­˜æ”¾åœ¨varå˜é‡ä¸­
å¦‚æœæ²¡æ‰¾åˆ°, è¿™ä¾èµ–äº




https://vimeo.com/32212195

### Comments æ³¨é‡Š

```cmake
# a single line comment

#[==[
    multi lines comments
    multi lines comments
    multi lines comments

    #[==[
        nested
        nested
    #]==]
#]==]
```

### Flow Control æµç¨‹æ§åˆ¶

#### if statement

```cmake
 if(<condition>)
   <commands>
 elseif(<condition>) # optional block, can be repeated
   <commands>
 else()              # optional block
   <commands>
 endif()
```

```cmake
set(var 9)

if(${var} LESS 10)
    message(STATUS "${var} less than 10")
endif(${var} LESS 10)

# è¿™ä¸ªvarä¼šè‡ªåŠ¨å»åŒ¹é…:çœ‹æœ‰æ²¡æœ‰åä¸ºvarè¿™ä¸ªå˜é‡,å¦‚æœæœ‰å°±ç”¨varçš„å€¼æ¥æ›¿æ¢,å¦‚æœæ²¡æœ‰å°±"var"è¿™ä¸ªå­—ç¬¦ä¸²
# ä¸å»ºè®®è¿™ç§ç”¨æ³•
if(var LESS 10)
    message(STATUS "${var} less than 10")
endif(var LESS 10)

set(var 50)
if(${var} LESS 10)
    message(STATUS "${var} less than 10")
elseif(${var} LESS 100)
    message(STATUS "${var} between 10 and 100")
endif(${var} LESS 10)
```

##### Condition

-   unary tests such as `EXISTS`, `COMMAND`, and `DEFINED`.

-   Then binary tests such as`EQUAL`, `LESS`, `LESS_EQUAL`, `GREATER`, `GREATER_EQUAL`,`STREQUAL`, `STRLESS`, `STRLESS_EQUAL`, `STRGREATER`,`STRGREATER_EQUAL`, `VERSION_EQUAL`, `VERSION_LESS`,`VERSION_LESS_EQUAL`, `VERSION_GREATER`, `VERSION_GREATER_EQUAL`,and `MATCHES`.

-   Then the boolean operators in the order `NOT`, `AND`, and finally `OR`.

##### True / False

-   True if the constant is `1`, `ON`, `YES`, `TRUE`, `Y`,or a non-zero number

-   False if the constant is `0`, `OFF`, `NO`, `FALSE`, `N`, `IGNORE`, `NOTFOUND`, the empty string, or ends in the suffix `-NOTFOUND`

> here is no automatic evaluation for environment or cache :ref:`Variable References`. Their values must be referenced as `$ENV{<name>}` or `$CACHE{<name>}` wherever the above-documented condition syntax accepts `<variable|string>`.

#### Foreach/while statement

```cmake
 foreach(<loop_var> <items>)
   <commands>
 endforeach()

 foreach(<loop_var> RANGE <stop>)
 foreach(<loop_var> RANGE <start> <stop> [<step>])
 foreach(loop_var IN [LISTS [<lists>]] [ITEMS [<items>]])

 break()
 continue()
```

```cmake
 set(A 0;1)
 set(B 2 3)
 set(C "4 5")
 set(D 6;7 8)
 set(E "")
 foreach(X IN LISTS A B C D E)
     message(STATUS "X=${X}")
 endforeach()
```

### Message

```cmake

```

### Macro

Start recording a macro for later invocation as a command

```cmake
 macro(<name> [<arg1> ...])
   <commands>
 endmacro()
```

```cmake
macro(foo)
   <commands>
endmacro()

# can be invoked through any of, case-insensitiveå¤§å°å†™ä¸æ•æ„Ÿ

foo()
Foo()
FOO()

macro(foo a b c d)
    message(STATUS "a = ${a}; b = ${b}; c = ${c}; d = ${d}" )
    message(STATUS "argc = ${ARGC}; argv = ${ARGV}")
    message(STATUS "arg0 = ${ARG0}; arg1 = ${ARG1}; arg2 = ${ARG2}")
    message(STATUS "argn = ${ARGN}") # foo()è°ƒç”¨æ—¶å¤šä½™çš„å‚æ•°é›†åˆ
endmacro()

foo(1 2 3 4 5 6 7)
```

å‡ ä¸ªå˜é‡

-   ARGC

-   ARGV - list of all arguments
-   ARGN - list of all arguments beyond the last formal parameter

*   ARG0, ARG1, ARG2....

#### Function(2.6 and later)

```cmake
 function(<name> [<arg1> ...])
   <commands>
 endfunction()
```

```cmake
 function(foo)
   <commands>
   set(var value PARENT_SCOPE)
 endfunction()

 # can be invoked through any of

 foo()
 Foo()
 FOO()
```

#### Common Commands

```cmake
cmake_minimun_required(VERSION 3.0.0)
project(project_name CXX)
set(lib_name sumdumlib)
add_library(${lib_name} source1.cxx source2.cxx ...)
add_executable(exe_name source1.cxx source2.cxx ...)
target_link_libraries(exe_name ${lib_name})
add_subdirectory(Tests)
```

#### All commands

```shell
cmake --help-command-list
cmake --help-command command_name
cmake --help command_name
cmake -h command_name
```

#### Variable Scope add_subdirectory and inheritance

add_subdirectory ä¼šåˆ†éš”æˆå¤šä¸ªç›®å½•æˆ–å­ç›®å½•

variable ä¹Ÿä¼šè¢«ç»§æ‰¿åˆ°å­ç›®å½•

#### CMakeCache.txt

å­˜å‚¨ä¸€äº›å¯é€‰, æä¾›é¡¹ç›®å…¨å±€å˜é‡çš„ repository

è¿™ä¸ªæ–‡ä»¶å°±æ˜¯ä¸€ä¸ª entries çš„é›†åˆ

```cmake
KEY:TYPE=VALUE
```

TYPE

-   BOOL
-   STRING
-   PATH
-   FILEPATH
-   INTERNAL

#### Variables and the Cache

CMakeCache.txt åœ¨ build ç›®å½•çš„é¡¶å±‚ç›®å½•ä¸‹

é‡æ–°è¿è¡Œçš„æ—¶å€™æ‰ä¼šç”¨

è®¾ç½®çš„ä¸¤ç§æ–¹æ³• option å’Œ set with cache

-   option(VAR "option var" TRUE)
-   set(VAR TRUE CACHE BOOL "bool var") # first time only
-   set(VAR TRUE CACHE BOOL "bool var" FORCE) # always

![image-20190906115149227](assets/image-20190906115149227.png)

![image-20190906115158255](assets/image-20190906115158255.png)

#### CMake Special Variables

```shell
> cmake --help-variable
--help-variable       -- Print help for a single variable and exit
--help-variable-list  -- List documented variables and exit
--help-variables      -- Print help for all variables and exit
```

##### User settable variables

-   BUILD_SHARED_LIBS
-   CMAKE_INSTALL_PREFIX

##### CMake pre-defined variables

-   WIN32, UNIX, APPLE, CMAKE_VERSION
-   CMAKE_SOURCE_DIR, CMAKE_BINARY_DIR
-   PROJECT_NAME
-   PROJECT_SOURCE_DIR, PROJEcT_BINARY_DIR

#### Building Libraries

```cmake
option(BUILD_SHARED_LIBS "build shared libs" OFF)
add_library(Mylib src1 ...)
add_library(MyShared SHARED src1 ...)
add_library(MyStatic STATIC src1 ...)
add_library(MyModule MODULE src1 ...)
add_library(Mylib src1 ...)
```

Library versions on UNIX

set_target_properties(myshared PROPERTIES VERSION 1.2 SOVERSION 4)

this result in the following library and symbolic link;

libmyshared.so.1.2

libmyshared.so.4 -> libmyshared.so.1.2

libmyshared.so -> libmyshared.so.4



Adding a library

* Using your favorite directory difference viewing tool shudy the differences between the Exercises Tutorial/Step1 and Tutorial/Step2 directories
* Follow the direction in Step2 of the "Tutorials" chapter of the book "Mastering CMake"
* Run cmake or cmake-gui to configure the project and then build it with your chosen build tool
* Run the build Tutorial executable
* Which function gives better results.



### Using Modules

* find_package(Tcl REQUIRED)
* include(FindTcl)



* cmake --help-module-list
* cmake --help-module module



### Build configurations

with makefile generators:

* CMAKE_BUILD_TYPE:STRING=Release
* Known values are: Debug, Release, MinSizeRel, RelWithDebInfo

to build multiple configurations with a Makefile generator, use multiple build trees

with IDE generators (visual studio / Xcode)

* CMAKE_CONFIGURATION_TYPES
  * = list of valid values for config types
* all binaries go into config subdirectory
* CMAKE_INTDIR(a C++ preprocessor symbol)
  * = active config directory
* CMAKE_CFG_INTDIR(a CMake variables)
  * `= "," or "$(OutDir)" or "$(CONFIGURATION)"`

CMAKE_CXX_FLAGS_<ConfigName>



## Setp3-adding install rules and tests

* study the differences between the exercises 



## System introspection

find_* commands

* find_file
* find_library
* find_package
* find_path
* find_program

try_compile

Macros to help with common tests

* CheckIncludeFileCXX.cmake
* CheckCSourceCompiles.cmake
* CheckIncludeFiles.cmake
* CheckCSourceRuns.cmake
* CheckLibraryExists.cmake
* CheckCXXCompilerFlag.cmake
* CheckSizeOf.cmake

try_run, but only if not cross-compiling

* CheckCXXSourceRuns.cmake
* CheckStructHasMember.cmake
* CheckSymbolExists.cmake
* CheckTypeSize.cmake
* CheckFunctionExists.cmake
* CheckIncludeFile.cmake
* CheckVariableExists.cmake

## Step4-adding system introspection checks

 

## Custom Commands

add_custom_command()

* Allows you to run arbitrary comands before, during, or after a target is built

* Can be used to generate new files

* Can be used to move or fixup generatored or compiled files



## Include command

```cmake
include(cmakefile)
include(cmakefile OPTIONAL)
include(${VTK_SOURCE_DIR}/Local.cmake OPTIONAL)
```

#### mark_as_advanced

* advanced variables are not displayed in the cache editors by default
* Allows for complicated, seldom changed options to be hidden form users

#### include_regular_expression

* CMkae adds dependency checking to Unix makefiles
* This command allow you to define which files have important dependencies and what happens when they can not be found

```cmake
include_regular_expression(
	regex_match
	[regex_complain])
```

* CMake will trace dependencies in regex_match files (ex vtk*)
* CMake will only complain about those that are also in regex_complain



## Cmake Scripts

cmake -E Command

* Cross platform command line utility for:
* Copy file, remove file, compare and conditionally copy, time, others

cmake -P script.cmake

* Cross platform scripting utility
* Dose not generate CMakeCache.txt
* Ignores commands specific to generating build enviroment



## Setp5-adding a generated file

### imported targets

logical name for an outside library

* reference like any other target

```cmake
add_library(math STATIC IMPORTED)
set_property(TARGET math PROPERTY IMPORTED_LOCATION /uer/lib/libm.a)
target_link_libraries(myexe math)
```

logical name for an outside executable

```cmake
add_executable(copy IMPORTED)
set_property(TARGET copy PROPERTY 
	IMPORTED_LOCATION /usr/bin/cp)
add_custom_command(OUTPUT foo.txt 
	COMMAND copy ${DIR}/foo.txt.in foo.txt
	DEPENDS ${DIR}/foo.txt.in)
```

Exporting Targets

* install eules can generate imported targets

```cmake
add_library(mylib STATIC mylib.c)
install(TARGETS mylib 
	DESTINATION lib
	EXPORT myproj-targets)
install(EXPORT myproj-targets
	DESTINATION lib/myproj)
```

* Install library and target import rules

```cmake
<prefix>/lib/libmylib.a
<prefix>/lib/myproj/myproj-targets.cmake
```



## Creating Packages

package config fiiles come with installation

```cmake
# myproj-config.cmake
include(${DIR}/myproj-targets.cmake)
set(myproj_INCLUDE_DIRECTORIES ${PREFIX}/include/myproj)

# myproj-config-version.cmake
set(PACKAGE_VERSION 1.3)
if("${PACKAGE_FING_VERSION_MAJOR}" RQUAL 1)
	set(PACKAGE_VERSION_COMPATIBLE 1)
endif()
```

## CTest

* Why and when to test
* Testing with cmake
* Testing with cdash

### Why Test

* if it si not tested , it does not work
* Tests take time, but there is a cost//benefit tradeoff
  * CMake tests 40% to 78% quality has improved
  * VTK tests 76%
* With good testing, global changes are much easier to make,
  * Object factory added to vtk's New, global change, and it was safe to do

create_test_sourcelist

Get around the problem of too many executables

```cmake
create_test_sourcelist(testSrcs 
	TestDriverTest
	test1
	test2
	surdir/test3
	EXTRA_INCLUDE testArgs.h FUNCTION testProcessArgs)
add_executable(TestDriverTest ${testSrcs})
```

creates "C" source code in TestDriverTest.cxx that can call test1() or test2() based on the command line

```cmake
add_test(test1 TestDriverTest test1)
```



* run CTest at the top of a binary directory to run all tests
  * -R option allows you to choose a test
  * -E exclude tests
  * -C ConfigDir (Debug, Release)
* Running tests from Makefiles or projects
  * make test
  * build RUN_TESTS project
* ctest --help for more information

## CPack

### What is CPack

* cross platform packaging and distribution tool
* package binary into native package format

### Using CPack

* On Windows install command line ZIP program, and NSIS
* Setup your project to work with cpack
  * get make install to work
    * install(...)
    * Make sure you executables work with relative paths and can work from and directory
  * set cpack option variables if needed
  * install(CPack)

* running cpack
  * make package  (create all packages)
  * make package_source (create source package)
  * cpack -C -CPackConfig.cmake -G NSIS
  * cpack -C -CPackConfig.cmake -G ZIP
  * cpack -C -CPackSourceConfig.cmake -G ZIP

#### Using CPack: Example Input

```cmake
project(CoolStuff)
add_executable(coolstuff coolstuff.cxx)
install(TARGETS coolstuff RUNTIME DESTIANTION bin)
set(CPACK_PACKAGE_EXECUTABLES "coolstuff" "the cool stuff")
install(CPack)
```

#### Using CPack: Example Output

> make package



### CPack and Visual Studio

* install the microsoft run time libraries
  * include(installRequiredSystemLibraries)
* That will add the run time libraries and all side-by-side manifests needed by your project  